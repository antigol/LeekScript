#include "VariableValue.hpp"
#include "Function.hpp"
#include "../../vm/VM.hpp"
#include "../instruction/VariableDeclaration.hpp"

using namespace std;

namespace ls {

VariableValue::VariableValue(Token* token) {
	this->name = token->content;
	this->token = token;
	this->var = nullptr;
	constant = false;
}

VariableValue::~VariableValue() {}

void VariableValue::print(ostream& os, int, bool debug) const {
	if (debug) os << "(";
	os << token->content;
	if (debug) {
		os << " " << var->type;
		if (type != var->type) os << "â†’" << type;
		os << ")";
	}
}

unsigned VariableValue::line() const {
	return token->line;
}

// DONE 1
void VariableValue::analyse_help(SemanticAnalyser* analyser)
{
	var = analyser->get_var(token);
	if (var == nullptr) return; // the error is generated by get_var

	left_type = var->type;
	type = var->type.image_conversion();
}

void VariableValue::reanalyse_l_help(SemanticAnalyser* analyser, const Type& req_type, const Type& req_left_type)
{
	assert(var);

	Type old = var->type;

	if (!Type::intersection(var->type, req_left_type, &var->type)) {
		add_error(analyser, SemanticException::INFERENCE_TYPE_ERROR);
	}
	if (!Type::intersection(type, var->type.image_conversion(), &type)) {
		add_error(analyser, SemanticException::INFERENCE_TYPE_ERROR);
	}
	if (!Type::intersection(type, req_type, &type)) {
		add_error(analyser, SemanticException::INFERENCE_TYPE_ERROR);
	}
	if (!Type::intersection(type.fiber_conversion(), var->type, &var->type)) {
		add_error(analyser, SemanticException::INFERENCE_TYPE_ERROR);
	}

	if (old != var->type) {
		left_type = var->type;

		if (var->scope) var->scope->reanalyse(analyser, Type::UNKNOWN);
	}
}

void VariableValue::finalize_l_help(SemanticAnalyser* analyser, const Type& req_type, const Type& req_left_type)
{
	//tip! var->type is already pure thanks to VD

	if (!Type::intersection(var->type, req_left_type)) {
		add_error(analyser, SemanticException::INFERENCE_TYPE_ERROR);
	}
	if (!Type::intersection(type, req_type, &type)) {
		add_error(analyser, SemanticException::INFERENCE_TYPE_ERROR);
	}
	if (!Type::intersection(type, var->type.image_conversion(), &type)) {
		add_error(analyser, SemanticException::INFERENCE_TYPE_ERROR);
	}
	type.make_it_pure();
	left_type = var->type;
}

extern map<string, jit_value_t> internals;

jit_value_t VariableValue::compile(Compiler& c) const
{
	jit_value_t v;
	switch (var->scope_type) {
		case VarScope::INTERNAL:
			v = internals[name];
			break;
		case VarScope::LOCAL:
			v = c.get_var(name).value;
			break;
		case VarScope::PARAMETER:
			v = jit_value_get_param(c.F, var->index);
			break;
		default:
			v = nullptr;
	}

	return Compiler::compile_convert(c.F, v, var->type, type);
}

jit_value_t VariableValue::compile_l(Compiler& c) const
{
	jit_value_t v;
	switch (var->scope_type) {
		case VarScope::INTERNAL:
			v = internals[name];
			break;
		case VarScope::LOCAL:
			v = c.get_var(name).value;
			break;
		case VarScope::PARAMETER:
			v = jit_value_get_param(c.F, var->index);
			break;
		default:
			v = nullptr;
	}

	return jit_insn_address_of(c.F, v);
}

}
